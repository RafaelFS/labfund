; T3G11A03E01_rotinas_12.asm
; Arquivo que contém as rotinas desenvolvidas nas aulas anteriores
				;						&       /0000
;Exportando PACK  ==================================================================
2004 0000 ; "PACK>"		;	PACK        		>           ; Sub-rotina PACK
2000 0000 ; "PACK_VAR1>"		;	PACK_VAR1   		>           ; Endereço da primeira palavra a ser empacotada
2002 0000 ; "PACK_VAR2>"		;	PACK_VAR2   		>           ; Endereço da segunda palabra a ser empacotada

;Exportando UNPACK  =======================================================================
202a 0000 ; "UNPACK>"		;	UNPACK				>			; Sub-rotina UNPACK
201e 0000 ; "UNPACK_OUT_ADDR1>"		;	UNPACK_OUT_ADDR1  	>	     	; Endereço de saída da primeira palavra 
2020 0000 ; "UNPACK_OUT_ADDR2>"		;	UNPACK_OUT_ADDR2 	>       	; Endereço de saída da segunda palavra 
2022 0000 ; "UNPACK_PACKAGE>"		;	UNPACK_PACKAGE     	>         	; Word empacotada

;Exportando MEMCOPY =======================================================================
2094 0000 ; "MEMCOPY>"		;	MEMCOPY 			>			; Subrotina MEMCOPY
2080 0000 ; "MEMCOPY_NWORDS>"		;	MEMCOPY_NWORDS 		> 			; Número de palavras a serem copiadas (cópia da subrotina)
2082 0000 ; "MEMCOPY_END_ORIGEM>"		;	MEMCOPY_END_ORIGEM	>			; Endereço inicial da sequência de origem (cópia da subrotina)
2084 0000 ; "MEMCOPY_END_DESTINO>"		;	MEMCOPY_END_DESTINO	>			; Endereço inicial da sequência de destino (cópia da subrotina)

;Exportando ITOCH ===============================================================================
210a 0000 ; "ITOCH>"		;	ITOCH 				>
20ea 0000 ; "ITOCH_END_SAIDA_1>"		;	ITOCH_END_SAIDA_1	>
20ec 0000 ; "ITOCH_END_SAIDA_2>"		;	ITOCH_END_SAIDA_2	>
20ee 0000 ; "ITOCH_ENTRADA>"		;	ITOCH_ENTRADA       >


;Importando constantes ===========================================================
4000 0000 ; "SHIFT1<"		;	SHIFT1				<		; Constante que desloca em 1 posição os bits das palavras
4001 0000 ; "SHIFT2<"		;	SHIFT2				<		; Constante que desloca em 2 posições os bits das palavras
4002 0000 ; "TRATA_NEG<"		;	TRATA_NEG			<		; Constante utilizada para passar um numero negativo para um positivo
4003 0000 ; "VOLTA_NEG<"		;	VOLTA_NEG			<		; Constante utilizada para voltar o número para negativo
4004 0000 ; "MM_VAZIA<"		;	MM_VAZIA			<		; Move to memory vazia para criação de instrução dinamicamente
4005 0000 ; "LD_VAZIA<"		;	LD_VAZIA    		<		; Load vazia para criação de intruções dinamicamente
4006 0000 ; "INC_ADDRESS<"		;	INC_ADDRESS			<		; Constante de incremento de endereço
4007 0000 ; "INCREASE<"		;	INCREASE			<		; Constante de decremento de contagem
4008 0000 ; "INVALID_ADDR<"		;	INVALID_ADDR		<       ; Constante de endereço invalido. Qualquer endereço igual ou maior que ele é inválido
4009 0000 ; "CHECK_DIGITO<"		;	CHECK_DIGITO		<		; Constante utilizada para checar se é digito (se você subtrair e for positivo, é letra)
4010 0000 ; "DIGITO_TO_HEX<"		;	DIGITO_TO_HEX		< 		; Constante que, somada com um digito, dá o seu código ASCII
4011 0000 ; "LETRA_TO_HEX<"		;	LETRA_TO_HEX		<		; Constante que, somada com uma letra, dá o seu código ASCII
	
; Subrotina PACK ===============================================================================
; Recebe o endereço de duas palavras e retorna no Acumulador a composição entre as duas

; Variáveis de PACK
8000 0000		;	PACK_VAR1   K /0000     ; Variavel do programa
8002 0000		;	PACK_VAR2   K /0000     ; Variavel do programa
; Corpo de PACK
8004 0000		;	PACK        K /0000             ; Sub-rotina PACK
a006 8000		;				LD      PACK_VAR1   ; Recebe o endereco de IN1 (conteudo de PACK_VAR1)
d008 4005		;				+       LD_VAZIA     ; Soma com (8000H)
a00a 900c		;				MM      PACK_X      ; Salva no proximo endereco de memoria
800c 0000		;	PACK_X      K       /0000       ; Executa a instrucao recem-montada
d00e 6001		;				*       SHIFT2      ; Multiplica por 100H
a010 9000		;				MM      PACK_VAR1   ; Salva na memoria PACK_VAR1
a012 8002		;				LD      PACK_VAR2   ; Recebe o endereco de IN2 (conteudo de PACK_VAR2)
d014 4005		;				+       LD_VAZIA    ; Soma com (8000H)
a016 9018		;				MM      PACK_Y      ; Salva no proximo endereco de memoria
8018 0000		;	PACK_Y      K       /0000       ; Executa a instrucao recem-montada
a01a 4000		;				+       PACK_VAR1   ; Soma com o conteudo de PACK_VAR1
a01c b004		;				RS      PACK        ; Fim da sub-rotina 


; Subrotina UNPACK =============================================================================
; Subrotina que desempacota a palavra presente no Acumulador e salva as palavras resultantes nos
; endereço armazenado em UNPACK_W1 e UNPACK_W2

;Variáveis de UNPACK
801e 0000		;	UNPACK_OUT_ADDR1  	K       /0000       	; Endereço de saída da primeira palavra 
8020 0000		;	UNPACK_OUT_ADDR2 	K       /0000       	; Endereço de saída da segunda palavra 
8022 0000		;	UNPACK_PACKAGE     	K       /0000       	; Word empacotada
8024 0000		;	UNPACK_W1          	K       /0000       	; Palavra 1 (2 primeiros digitos da original)
8026 0000		;	UNPACK_W2       	K       /0000       	; Palavra 2 (2 ultimos digitos da original)
8028 0000		;	UNPACK_W1_DESLOCADA K       /0000       	; A primeira palavra deslocada

;Corpo da subrotina
802a 0000		;	UNPACK      		K       /0000       			; Início da subrotina UNPACK (endereço reservado para retorno)
a02c 9022		;						MM      UNPACK_PACKAGE  		; Copia o contéudo do Acumulador para PACKAGE;
a02e 2056		;						JN      UNPACK_NEGATIVO 		; Se a palavra é um número negativo, pula para o caso NEGATIVO
d030 7001		;	UNPACK_POSITIVO    	/       SHIFT2 	    			; Se a palavra é positiva, divido por /100 para obter a primeira palavra no Acumulador
a032 9024		;						MM      UNPACK_W1 				; Copio a primeira palavra em W1;
a034 801e		;						LD      UNPACK_OUT_ADDR1		; Copio o endereço de saída da primeira palavra para o Acumulador
d036 4004		;						+       MM_VAZIA     			; Combina o endereço de saída da primeira palavra com a isntrução MM
a038 903c		;						MM      UNPACK_SALVA1   		; Tranfere a instrução completa para a posição SALVA1
a03a 8024		;						LD      UNPACK_W1       		; Copia o valor de W1 para o Acumulador
803c 0000		;	UNPACK_SALVA1      	K       /0000       			; Executa a instrução MM <valor contido em W1XADDRESS>, salvando a palavra 1 na posição de saída desejada
a03e 8024		;						LD      UNPACK_W1       		; Copia o valor de W1 para o Acumulador
d040 6001		;						*       SHIFT2 					; Multiplica a primeira palavra por /100 para deslocá-la duas posições para a direita
a042 9028		;						MM      UNPACK_W1_DESLOCADA 	; Salvo a palavra 1 deslocada em W1DESLOCADA
a044 8022		;						LD      UNPACK_PACKAGE     		; Copio a palavra empacotada para o Acumulador
a046 5028		;						-       UNPACK_W1_DESLOCADA 	; Subtraio os dois primeiros digitos da palavra empacotada para obter a segunda palavra
a048 9026		;						MM      UNPACK_W2          		; Copio a segunda palavra em W2;
a04a 8020		;						LD      UNPACK_OUT_ADDR2		; Copio o endereço de saída da segunda palavra para o Acumulador
d04c 4004		;						+       MM_VAZIA     			; Combina o endereço de saída da segunda palavra com a instrução MM
a04e 9052		;						MM      UNPACK_SALVA2      		; Tranfere a instrução completa para a posição SALVA1
a050 8026		;						LD      UNPACK_W2          		; Copia o valor de W2 para o Acumulador
8052 0000		;	UNPACK_SALVA2      	K       /0000       			; Executa a instrução MM <valor contido em W1XADDRESS>, salvando a palavra 1 na posição de saída desejada
a054 007e		;						JP      UNPACK_FIM 	    
d056 4002		;	UNPACK_NEGATIVO    	+       TRATA_NEG    			; Soma 8000 no numero negativo para poder tratar como positivo
d058 7001		;						/       SHIFT2 					; Divido por /100 para obter a primeira palavra passada para positiva no Acumulador
d05a 4003		;						+       VOLTA_NEG    			; Soma 80 para passar a primeira palavra para positiva
a05c 9024		;						MM      UNPACK_W1          		; Copio a primeira palavra em W1;
a05e 801e		;						LD      UNPACK_OUT_ADDR1  		; Copio o endereço de saída da primeira palavra para o Acumulador
d060 4004		;						+       MM_VAZIA     			; Combina o endereço de saída da primeira palavra com a isntrução MM
a062 9066		;						MM      UNPACK_SALVA3      		; Tranfere a instrução completa para a posição SALVA1
a064 8024		;						LD      UNPACK_W1          		; Copia o valor de W1 para o Acumulador
8066 0000		;	UNPACK_SALVA3      	K       /0000       			; Executa a instrução MM <valor contido em W1XADDRESS>, salvando a palavra 1 na posição de saída desejada
a068 8024		;						LD      UNPACK_W1         		; Copia o valor de W1 para o Acumulador
d06a 6001		;						*       SHIFT2		  			; Multiplica a primeira palavra por /100 para deslocá-la duas posições para a direita
a06c 9028		;						MM      UNPACK_W1_DESLOCADA 	; Salvo a palavra 1 deslocada em W1DESLOCADA
a06e 8022		;						LD      UNPACK_PACKAGE			; Copio a palavra empacotada para o Acumulador
a070 5028		;						-       UNPACK_W1_DESLOCADA 	; Subtraio os dois primeiros digitos da palavra empacotada para obter a segunda palavra
a072 9026		;						MM      UNPACK_W2          		; Copio a segunda palavra em W2;
a074 8020		;						LD      UNPACK_OUT_ADDR2  		; Copio o endereço de saída da segunda palavra para o Acumulador
d076 4004		;						+       MM_VAZIA     			; Combina o endereço de saída da segunda palavra com a instrução MM
a078 907c		;						MM      UNPACK_SALVA4      		; Tranfere a instrução completa para a posição SALVA1
a07a 8026		;						LD      UNPACK_W2          		; Copia o valor de W2 para o Acumulador
807c 0000		;	UNPACK_SALVA4      	K       /0000       			; Executa a instrução MM <valor contido em W1XADDRESS>, salvando a palavra 1 na posição de saída desejada
a07e b02a		;	UNPACK_FIM	 		RS      UNPACK      			; Retorno da subrotina


; Subrotina MEMCOPY =============================================================================
; Subrotina que copia uma sequência de tamanho arbitrário de bytes da 
; memória de uma posição em outra. Retorna 0000 no Acumulador em caso de 
; sucesso e FFFF em caso de erro

;Variáveis da Subrotina
8080 0000		;	MEMCOPY_NWORDS 				K		/0000					; Número de palavras a serem copiadas (cópia da subrotina)
8082 0000		;	MEMCOPY_END_ORIGEM			K		/0000					; Endereço inicial da sequência de origem (cópia da subrotina)
8084 0000		;	MEMCOPY_END_DESTINO			K		/0000					; Endereço inicial da sequência de destino (cópia da subrotina)
8086 0000		;	MEMCOPY_ORIGEM_ATUAL		K		/0000					; Endereço atual que eu estou lendo	
8088 0000		;	MEMCOPY_DESTINO_ATUAL		K		/0000					; Endereço atual para onde estou copiando
808a 0000		;	MEMCOPY_CONTAGEM			K		/0000					; Número de palavras que ainda preciso copiar
808c 0000		;	MEMCOPY_OK					K		/0000					; Código de retorno de funcionamento correto
808e ffff		;	MEMCOPY_ERRO 				K		/FFFF					; Código de retorno de caso de erro 
8090 0000		;	MEMCOPY_COPIANDO 			K		/0000					; Dado que está sendo copiado
8092 0000		;	MEMCOPY_RETORNO				K		/0000					; Retorno da subrotina

;Corpo da Subrotina
8094 0000		;	MEMCOPY						K 		/0000					; Início da subrotina MEMCOPY (endereço reservado para retorno)
							; Tratando erros	
a096 8082		;	MEMCOPY_ERRO_CHK_1			LD      MEMCOPY_END_ORIGEM 		; Copio o endereço de origem para o Acumulador
d098 5008		;								-		INVALID_ADDR			; Subtraio o endereço pelo primeiro endereço inválido 
a09a 20a0		;								JN		MEMCOPY_ERRO_CHK_2		; Se for negativo, o endereço é válido e pula para o segundo check
a09c 808e		;	MEMCOPY_ERRO_1_DETECTADO	LD 		MEMCOPY_ERRO            ; Se entrou aqui, o endereço é inválido. Copio o código de erro no Acumulador.
a09e 9092		;								MM 		MEMCOPY_RETORNO 		; Copio o código de erro em RETORNO
a0a0 8084		;	MEMCOPY_ERRO_CHK_2			LD      MEMCOPY_END_DESTINO  	; Copio o endereço de origem para o Acumulador
d0a2 5008		;								-		INVALID_ADDR			; Subtraio o endereço pelo primeiro endereço inválido 
a0a4 20aa		;								JN		MEMCOPY_ERRO_CHK_FIM	; Se for negativo, o endereço é válido
a0a6 808e		;	MEMCOPY_ERRO_2_DETECTADO	LD 		MEMCOPY_ERRO            ; Se entrou aqui, o endereço é inválido. Copio o código de erro no Acumulador.
a0a8 9092		;								MM 		MEMCOPY_RETORNO 		; Copio o código de erro em RETORNO
a0aa 8092		;	MEMCOPY_ERRO_CHK_FIM		LD 		MEMCOPY_RETORNO         ; Carrego RETORNO no Acumulador
a0ac 10b0		;								JZ		MEMCOPY_INICIO			; Se retorno = 0, continuo, senão pulo pro final
a0ae 00e6		;								JP		MEMCOPY_FIM		
							; Inicio colocando os valores iniciais das variáveis de controle
a0b0 8082		;	MEMCOPY_INICIO				LD      MEMCOPY_END_ORIGEM  	; Copio o endereço de origem para o Acumulador
a0b2 9086		;								MM 		MEMCOPY_ORIGEM_ATUAL   	; Copio o endereço de origem para endereço que estou lendo
a0b4 8084		;								LD      MEMCOPY_END_DESTINO 	; Copio o endereço de destino para o Acumulador
a0b6 9088		;								MM 		MEMCOPY_DESTINO_ATUAL   ; Copio o endereço de destino para endereço que estou lendo
							;Inicia contagem			
a0b8 8080		;								LD      MEMCOPY_NWORDS     		; Copio o número de palavras para o Acumulador
a0ba 908a		;								MM 		MEMCOPY_CONTAGEM    	; Copio o número de palavras para CONTAGEM
							; Loop de copias			
a0bc 10e6		;	MEMCOPY_LOOP 				JZ		MEMCOPY_FIM  			; Pula para fora do LOOP se CONTAGEM = 0
a0be 8086		;								LD 		MEMCOPY_ORIGEM_ATUAL   	; Copio o endereço atual a ser lido para o Acumulador
d0c0 4005		;								+		LD_VAZIA     			; Somo o endeço atual a ser lido com a instrução de LOAD, obtendo uma instrução que lê o valor atual
a0c2 90c4		;								MM		MEMCOPY_COPIA_ATUAL 	; Envio a instrução que lê o valor atual para COPIAATUAL
80c4 0000		;	MEMCOPY_COPIA_ATUAL			K 		/0000					; Executa instrução que lê o valor atual
a0c6 9090		;								MM 		MEMCOPY_COPIANDO    	; Copia o valor atual para COPIANDO
a0c8 8088		;								LD 		MEMCOPY_DESTINO_ATUAL   ; Copio o endereço atual de destino para o Acumulador
d0ca 4004		;								+		MM_VAZIA     			; Somo o endereço atual de destino com a instrução de MM, obtendo uma instrução que envia para o destino atual
a0cc 90d0		;								MM		MEMCOPY_ENVIA_ATUAL 	; Envio a instrução que envia para o destino atual para ENVIAATUAL
a0ce 8090		;								LD 		MEMCOPY_COPIANDO    	; Copio o valor atual para o Acumulador
80d0 0000		;	MEMCOPY_ENVIA_ATUAL			K 		/0000					; Executa instrução que envia para o destino atual
							;Incrementando os endereços e decrementando a CONTAGEM
a0d2 8086		;								LD 		MEMCOPY_ORIGEM_ATUAL 	; Incremento o endereço de origem para pegar o próximo valor a ser copiado  
d0d4 4006		;								+ 		INC_ADDRESS
a0d6 9086		;								MM      MEMCOPY_ORIGEM_ATUAL 
a0d8 8088		;								LD 		MEMCOPY_DESTINO_ATUAL   ; Incremento o endeço de destino para que a cópia ocupa a próxima posição da sequencia
d0da 4006		;								+ 		INC_ADDRESS
a0dc 9088		;								MM      MEMCOPY_DESTINO_ATUAL
a0de 808a		;								LD 		MEMCOPY_CONTAGEM		; Decremento a contagem de palavras que faltam copiar
d0e0 5007		;								- 		INCREASE 				
a0e2 908a		;								MM 		MEMCOPY_CONTAGEM
a0e4 00bc		;								JP		MEMCOPY_LOOP 			; Retorna ao Inicio do LOOP 
a0e6 8092		;	MEMCOPY_FIM					LD 		MEMCOPY_RETORNO			; Coloco o valor de RETORNO no Acumulador
a0e8 b094		;								RS 		MEMCOPY					; Retorno da subrotina
							

; Subrotina ITOCH ===================================================================================================
; Subrotina que converte um número inteiro do acumulador em duas words com os caracteres ASCII hexadecimais 
; correspondentes, colocando-os em dois endereços da memória.

; Variáveis da Subrotina ITOCH
80ea 0000		;	ITOCH_END_SAIDA_1			K		/0000 ; Endereço de saída de ITOCH (bits mais significativos)
80ec 0000		;	ITOCH_END_SAIDA_2			K		/0000 ; Endereço de saída de ITOCH (bits menos significativos)
80ee 0000		;	ITOCH_ENTRADA				K		/0000 ; Cópia da entrada de ITOCH
80f0 0000		;	ITOCH_WORD_1				K		/0000 ; Palavra mais significativa da entrada
80f2 0000		;	ITOCH_WORD_2				K		/0000 ; Palavra menos significativa da entrada
80f4 0000		;	ITOCH_DIG_1					K		/0000 ; Entradas separada em dígitos: 1 é o digito mais significativo, 4 é o menos significativo
80f6 0000		;	ITOCH_DIG_2					K		/0000
80f8 0000		;	ITOCH_DIG_3					K		/0000
80fa 0000		;	ITOCH_DIG_4					K 		/0000
80fc 0004		;	ITOCH_CONTADOR_CHEIO		K 		/0004 ; Valor máximo de contador
80fe 0000		;	ITOCH_CONTADOR_ATUAL        K		/0000 ; Valor atual do contador
8100 0000		;	ITOCH_END_LOOP_ATUAL		K 		/0000
8102 0000		;	ITOCH_LOOP_VALOR_ATUAL      K       /0000
8104 0000		;	ITOCH_LOOP_COD_ATUAL		K 		/0000
8106 0000		;	ITOCH_VALOR_SAIDA_1 		K 		/0000
8108 0000		;	ITOCH_VALOR_SAIDA_2 		K 		/0000
;Corpo da Subrotina
810a 0000		;	ITOCH						K 		/0000					; Início da subrotina ITOCH (endereço reservado para retorno)
a10c 90ee		;								MM 		ITOCH_ENTRADA 			; Copia a entrada presente no Acumulador para a posição ITOCH_ENTRADA
a10e 30f0		;	ITOCH_SEPARANDO_PALAVRAS	LV		ITOCH_WORD_1 			; Coloca o endereço de ITOCH_WORD_1 no Acumulador
a110 901e		;								MM 		UNPACK_OUT_ADDR1		; Copia o conteúdo do Acumulador para UNPACK_OUT_ADDR1
a112 30f2		;								LV		ITOCH_WORD_2 			; Coloca o endereço de ITOCH_WORD_2 no Acumulador
a114 9020		;								MM 		UNPACK_OUT_ADDR2		; Copia o conteúdo do Acumulador para UNPACK_OUT_ADDR2
a116 80ee		;								LD		ITOCH_ENTRADA 			; Copia o conteúdo de ITOCH_ENTRADA para o Acumulador
a118 a02a		;								SC  	UNPACK      			; Executa a subrotina UNPACK para separar as duas palavras						
a11a 30f4		;	ITOCH_SEPARA_DIGITOS_1_E_2	LV		ITOCH_DIG_1 			; Coloca o endereço de ITOCH_DIG_1 no Acumulador
a11c 901e		;								MM 		UNPACK_OUT_ADDR1		; Copia o conteúdo do Acumulador para UNPACK_OUT_ADDR1
a11e 30f6		;								LV		ITOCH_DIG_2 			; Coloca o endereço de ITOCH_DIG_2 no Acumulador
a120 9020		;								MM 		UNPACK_OUT_ADDR2		; Copia o conteúdo do Acumulador para UNPACK_OUT_ADDR2
a122 80f0		;								LD 		ITOCH_WORD_1			; Copia a primeira palavra para o Acumulador
d124 6000		;								* 		SHIFT1					; Desloco os digitos para o meio da palavra
a126 a02a		;								SC 		UNPACK 					; Separo os digitos com a ajuda de UNPACK		
a128 80f6		;								LD 		ITOCH_DIG_2             ; Carrego o segundo digito para corrigir a posição 
d12a 7000		;								/		SHIFT1					; Corrijo a posição através de um deslocamento para a direita
a12c 90f6		;								MM 		ITOCH_DIG_2
a12e 30f8		;	ITOCH_SEPARA_DIGITOS_3_E_4  LV		ITOCH_DIG_3 			; Coloca o endereço de ITOCH_DIG_3 no Acumulador
a130 901e		;								MM 		UNPACK_OUT_ADDR1		; Copia o conteúdo do Acumulador para UNPACK_OUT_ADDR1
a132 30fa		;								LV		ITOCH_DIG_4 			; Coloca o endereço de ITOCH_DIG_4 no Acumulador
a134 9020		;								MM 		UNPACK_OUT_ADDR2		; Copia o conteúdo do Acumulador para UNPACK_OUT_ADDR2
a136 80f2		;								LD 		ITOCH_WORD_2			; Copia a segunda palavra para o Acumulador
d138 6000		;								* 		SHIFT1					; Desloco os digitos para o meio da palavra
a13a a02a		;								SC 		UNPACK 					; Separo os digitos com a ajuda de UNPACK		
a13c 80fa		;								LD 		ITOCH_DIG_4             ; Carrego o ultimo digito para corrigir a posição 
d13e 7000		;								/		SHIFT1					; Corrijo a posição através de um deslocamento para a direita
a140 90fa		;								MM 		ITOCH_DIG_4
a142 80fc		;	ITOCH_PREPARA_LOOP			LD 		ITOCH_CONTADOR_CHEIO	
a144 90fe		;								MM 		ITOCH_CONTADOR_ATUAL
a146 30f4		;								LV 		ITOCH_DIG_1
a148 9100		;								MM 		ITOCH_END_LOOP_ATUAL	; Guardo o valor do endereço do primeiro digito em ITOCH_END_LOOP_ATUAL						
a14a 8100		;	ITOCH_CONVERSAO_LOOP		LD 		ITOCH_END_LOOP_ATUAL 	; Salvo o valor do endereço a ser lido
d14c 4005		;								+		LD_VAZIA				; Combino com LOAD
a14e 9150		;								MM		ITOCH_OBTER_VALOR_ATUAL	; Mando a instrução combinada para a proxima linha				
8150 0000		;	ITOCH_OBTER_VALOR_ATUAL		K		/0000					; Leio o valor atual
a152 9102		;								MM 		ITOCH_LOOP_VALOR_ATUAL	; Guardo o valor atual em ITOCH_LOOP_VALOR_ATUAL							
d154 5009		;								-		CHECK_DIGITO			; Se subtrair CHECK_DIGITO e for negativo...
a156 215e		;								JN		ITOCH_EH_NUMERO			; ...pulo para caso Numero
a158 8102		;	ITOCH_EH_LETRA				LD 		ITOCH_LOOP_VALOR_ATUAL	; Se estou aqui é Letra e obtenho o valor atual
d15a 4011		;								+ 		LETRA_TO_HEX			; Transformo no código ASCII
a15c 0162		;								JP		ITOCH_FIM_DE_LOOP 		; Com o código no acumulador, vou para o fim do loop
a15e 8102		;	ITOCH_EH_NUMERO             LD 		ITOCH_LOOP_VALOR_ATUAL	; Se é número, obtenho o valor atual
d160 4010		;								+ 		DIGITO_TO_HEX 			; Transformo no código atual
a162 9104		;	ITOCH_FIM_DE_LOOP			MM 		ITOCH_LOOP_COD_ATUAL	; Salvo o código atual na memória
a164 8100		;								LD 		ITOCH_END_LOOP_ATUAL 	; Pego o valor do endereço atual sendo manipulado
d166 4004		;								+		MM_VAZIA				; Combino com MM
a168 916a		;								MM 		ITOCH_SALVA_RESULTADO	; Mando a instrução montada para a próxima linha
816a 0000		;	ITOCH_SALVA_RESULTADO		K 		/0000					; Salvo o resultado da iteração no endereço correspondentes
a16c 8100		;	ITOCH_RETORNO_DE_LOOP       LD 		ITOCH_END_LOOP_ATUAL
d16e 4006		;								+ 		INC_ADDRESS
a170 9100		;								MM 		ITOCH_END_LOOP_ATUAL
a172 80fe		;								LD 		ITOCH_CONTADOR_ATUAL
d174 5007		;								- 		INCREASE
a176 90fe		;								MM      ITOCH_CONTADOR_ATUAL
a178 117c		;								JZ		ITOCH_FIM_DO_LOOP
a17a 014a		;								JP		ITOCH_CONVERSAO_LOOP
a17c 30f4		;	ITOCH_FIM_DO_LOOP			LV 		ITOCH_DIG_1			; Recebe o endereco de memoria de ITOCH_DIG_1	
a17e 9000		;								MM 		PACK_VAR1			; Salva o endereco na memoria PACK_VAR1
a180 30f6		;								LV 	 	ITOCH_DIG_2 		; Recebe o endereco de memoria de ITOCH_DIG_2
a182 9002		;								MM 		PACK_VAR2			; Salva o endereco na memoria PACK_VAR2
a184 a004		;								SC 		PACK 				; Chama a sub-rotina PACK
a186 9106		;								MM 		ITOCH_VALOR_SAIDA_1	; Salva o resultado em ITOCH_VALOR_SAIDA_1
a188 30f8		;								LV 		ITOCH_DIG_3			; Recebe o endereco de memoria de ITOCH_DIG_3	
a18a 9000		;								MM 		PACK_VAR1			; Salva o endereco na memoria PACK_VAR1
a18c 30fa		;								LV 	 	ITOCH_DIG_4 		; Recebe o endereco de memoria de ITOCH_DIG_4
a18e 9002		;								MM 		PACK_VAR2			; Salva o endereco na memoria PACK_VAR2
a190 a004		;								SC 		PACK 				; Chama a sub-rotina PACK
a192 9108		;								MM 		ITOCH_VALOR_SAIDA_2	; Salva o resultado em ITOCH_VALOR_SAIDA_2
a194 80ea		;								LD 		ITOCH_END_SAIDA_1 	; Pego o primeiro endereço de saída
d196 4004		;								+ 		MM_VAZIA 			; Combina com a instrução MM
a198 919c		;								MM 		ITOCH_SALVA_SAIDA_1	; Salva a instrução montada
a19a 8106		;								LD      ITOCH_VALOR_SAIDA_1 ; Pego o valor da primeira saída
819c 0000		;	ITOCH_SALVA_SAIDA_1			K 		/0000				; Executa instrução montada para salvar a primeira saída

a19e 80ec		;								LD 		ITOCH_END_SAIDA_2 	; Pego o primeiro endereço de saída
d1a0 4004		;								+ 		MM_VAZIA 			; Combina com a instrução MM
a1a2 91a6		;								MM 		ITOCH_SALVA_SAIDA_2	; Salva a instrução montada
a1a4 8108		;								LD      ITOCH_VALOR_SAIDA_2 ; Pego o valor da primeira saída
81a6 0000		;	ITOCH_SALVA_SAIDA_2			K 		/0000				; Executa instrução montada para salvar a primeira saída
a1a8 b10a		;	ITOCH_FIM_DA_SUBROTINA		RS 		ITOCH

