				;					& 		/0000
;Exportando as constantes ================================================================
2000 0000 ; "SHIFT1>"		;	SHIFT1			>
2002 0000 ; "SHIFT2>"		;	SHIFT2			>
2004 0000 ; "TRATA_NEG>"		;	TRATA_NEG		>
2006 0000 ; "VOLTA_NEG>"		;	VOLTA_NEG 		>
2008 0000 ; "MM_VAZIA>"		;	MM_VAZIA		>
200a 0000 ; "LD_VAZIA>"		;	LD_VAZIA		>
200c 0000 ; "INC_ADDRESS>"		;	INC_ADDRESS 	>
200e 0000 ; "INCREASE>"		;	INCREASE		>
2010 0000 ; "INVALID_ADDR>"		;	INVALID_ADDR	>
2012 0000 ; "CHECK_DIGITO>"		;	CHECK_DIGITO	>
2014 0000 ; "DIGITO_TO_HEX>"		;	DIGITO_TO_HEX	> 		
2016 0000 ; "LETRA_TO_HEX>"		;	LETRA_TO_HEX	>		
;Definição e valores das contantes =============================================================
8000 0010		;	SHIFT1			K		/0010		; Constante que desloca em 1 posição os bits das palavras
8002 0100		;	SHIFT2			K 		/0100		; Constante que desloca em 2 posições os bits das palavras
8004 8000		;	TRATA_NEG		K		/8000		; Constante utilizada para passar um numero negativo para um positivo
8006 0080		;	VOLTA_NEG		K		/0080		; Constante utilizada para voltar o número para negativo
8008 9000		;	MM_VAZIA		MM      /0000		; Move to memory vazia para criação de instrução dinamicamente
800a 8000		;	LD_VAZIA    	LD 		/0000		; Load vazia para criação de intruções dinamicamente
800c 0002		;	INC_ADDRESS		K		/0002		; Constante de incremento de endereço
800e 0001		;	INCREASE		K 		/0001		; Constante de decremento de contagem
8010 1000		;	INVALID_ADDR	K		/1000       ; Constante de endereço invalido. Qualquer endereço igual ou maior que ele é inválido
8012 000a		;	CHECK_DIGITO	K 		/000A		; Constante utilizada para checar se é digito (se você subtrair e for positivo, é letra)
8014 0030		;	DIGITO_TO_HEX	K 		/0030		; Constante que, somada com um digito, dá o seu código ASCII
8016 0037		;	LETRA_TO_HEX	K		/0037		; Constante que, somada com uma letra, dá o seu código ASCII
